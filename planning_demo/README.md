# RRT路径规划算法可视化

本项目实现了RRT（Rapidly-exploring Random Tree）和RRT*（RRT-Star）两种路径规划算法的可视化。

## 算法介绍

### RRT算法

RRT（Rapidly-exploring Random Tree）是一种用于在高维空间中进行路径规划的采样算法。它通过随机采样的方式逐步构建一棵树，直到找到一条从起点到目标点的路径。

RRT算法的基本步骤：
1. 从起点开始构建树
2. 随机采样一个点
3. 找到树中离随机点最近的节点
4. 从最近节点向随机点方向扩展一定距离，生成新节点
5. 如果新节点与障碍物不碰撞，则将其添加到树中
6. 重复步骤2-5，直到树能够连接到目标点或达到最大迭代次数

### RRT*算法

RRT*是RRT的改进版本，它保证了路径的渐进最优性。RRT*在RRT的基础上增加了两个关键步骤：

1. **选择父节点**：对于新生成的节点，不仅考虑最近的节点作为父节点，还考虑附近所有节点，选择使得从起点到新节点总成本最小的节点作为父节点。

2. **重布线**：在添加新节点后，检查是否可以通过新节点来改善附近节点的路径成本，如果可以则重新连接这些节点。

## 项目文件结构

- `RRT.py`: RRT算法的实现
- `RRTStar.py`: RRT*算法的实现
- `compare_rrt.py`: 比较RRT和RRT*算法的性能和路径质量
- `README.md`: 项目说明文档

## 使用方法

### 运行RRT算法

```python
python RRT.py
```

这将启动一个RRT算法的演示，显示随机树的生长过程和最终找到的路径。

### 运行RRT*算法

```python
python RRTStar.py
```

这将启动一个RRT*算法的演示，显示随机树的生长过程和最终找到的路径。

### 比较两种算法

```python
python compare_rrt.py
```

这将同时运行RRT和RRT*算法，并在同一个窗口中显示两种算法的结果，包括路径长度和计算时间的比较。

## 参数调整

您可以通过修改代码中的以下参数来调整算法的行为：

- `start`: 起点坐标 [x, y]
- `goal`: 终点坐标 [x, y]
- `obstacles`: 障碍物列表，每个障碍物为 [x, y, width, height]
- `rand_area`: 随机采样区域 [min_x, max_x, min_y, max_y]
- `expand_dis`: 扩展距离
- `goal_sample_rate`: 采样目标点的概率 (%)
- `max_iter`: 最大迭代次数
- `connect_circle_dist`: (仅RRT*)重布线半径

## 依赖库

- NumPy
- Matplotlib

## 安装依赖

```bash
pip install numpy matplotlib
```

## 示例结果

运行比较脚本后，您将看到类似下面的输出：

```
比较RRT和RRT*算法

===== 算法比较结果 =====
RRT 算法:
  - 路径长度: 142.56
  - 计算时间: 0.2345秒

RRT* 算法:
  - 路径长度: 128.73
  - 计算时间: 0.5678秒

RRT*相比RRT路径长度改进: 9.70%
```

同时，会显示一个包含两种算法结果的可视化窗口，直观地展示两种算法的区别。 