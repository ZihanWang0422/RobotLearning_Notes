# Mobile Robots

[å¯è§†åŒ–Python](https://github.com/zhm-real/PathPlanning)

[MRPT](https://docs.mrpt.org/reference/latest/index.html)

## Chapter 1 Mapping

### 1.structure

<img src="./Motion Planning.assets/image-20250417095645143.png" alt="image-20250417095645143" style="zoom: 50%;" />

### 2.Occupancy grid map 

[grid map code](https://github.com/ANYbotics/grid_map)

* åŸç†ï¼šå°†å¹³é¢åœ°å›¾é€šè¿‡gridè¿›è¡Œåˆ†å‰²ï¼Œæ¯ä¸ªæ …æ ¼ç”¨0,1è¡¨ç¤ºï¼ˆ0 - freeï¼Œ1 - occupiedï¼‰

  ![image-20250418120646301](./Motion Planning.assets/image-20250418120646301.png)

* Notation Defination

![image-20250418121448522](./Motion Planning.assets/image-20250418121448522.png)

<img src="./Motion Planning.assets/image-20250418122148617.png" alt="image-20250418122148617" style="zoom: 80%;" />

* Recursive Update

ğŸ™Œæ¨å¯¼ï¼šç”±è´å¶æ–¯å…¬å¼ï¼š
$$
\begin{aligned}p(m_{i}|z_{1:t}) & =\frac{p(z_{t}|z_{1:t-1},m_{i})p(m_{i}|z_{1:t-1})}{p(z_{t}|z_{1:t-1})}\\  & \left(é©¬å°”ç§‘å¤«è¿‡ç¨‹\right)=\frac{p(z_{t}|m_{i})p(m_{i}|z_{1:t-1})}{p(z_{t}|z_{1:t-1})}\\  & (è´å¶æ–¯å±•å¼€)=\frac{p(m_{i}|z_{t})p(z_{t})}{p(m_{i})}\frac{p(m_{i}|z_{1:t-1})}{p(z_{t}|z_{1:t-1})}\end{aligned}
$$

$$
p(\overline{m_i}|z_{1:t})=\frac{p(\overline{m_i}|z_t)p(z_t)}{p(\overline{m_i})}\frac{p(\overline{m_i}|z_{1:t-1})}{p(z_t|z_{1:t-1})}
$$

 å¯¹ä¸Šè¿°ä¸¤å¼ç›¸é™¤ï¼Œå¹¶å–logï¼š
$$
\log\frac{p(m_i|z_{1:t})}{p(\overline{m_i}|z_{1:t})}=\log\frac{p(m_i|z_t)}{p(\overline{m_i}|z_t)}\frac{p(\overline{m_i})}{p(m_i)}\frac{p(m_i|z_{1:t-1})}{p(\overline{m_i}|z_{1:t-1})}
$$
é€’å½’æ›´æ–°è¡¨è¾¾å¼ï¼šï¼ˆåŒ–ç®€log -> lï¼‰
$$
l_{t}(m_{i})=\log\frac{p(m_{i}|z_{t})}{p(\overline{m_{i}}|z_{t})}-l_0(m_i)+l_{t-1}(m_{i})
$$
å…¶ä¸­ï¼Œ

P(z|m)æ˜¯ä¼ æ„Ÿå™¨æ¨¡å‹ - è¡¨ç¤ºåŸºäºå½“å‰æ …æ ¼çŠ¶æ€å¾—åˆ°å½“å‰è§‚æµ‹å€¼ä¸º0/1çš„æ¦‚ç‡

P(m|z)æ˜¯é€†ä¼ æ„Ÿå™¨æ¨¡å‹ï¼Œä¸ºäº†çº¦å»å®ƒï¼Œåšå¦‚ä¸‹å˜æ¢ï¼Œå¹¶å¸¦å…¥åˆ°é€’å½’æ›´æ–°è¡¨è¾¾å¼ä¸­ï¼š
$$
\begin{cases}p(m_i|z_t)=\frac{p(z_t|m_i)p(m_i)}{p(z_t)}\\p(\overline{m_i}|z_t)=\frac{p(z_t|\overline{m_i})p(\overline{m_i})}{p(z_t)}&\end{cases}
$$

$$
\log\frac{p(m_i|z_t)}{p(\overline{m_i|z_t})}=\log\frac{p(z_t|m_i)}{p(z_t|\overline{m_i})}+l_0(m_i)
$$

$$
âœ¨l_t(m_i)=\log\frac{p(z_t|m_i)}{p(z_t|\overline{m_i})}+l_{t-1}(m_i)
$$

![image-20250418210446286](./Motion Planning.assets/image-20250418210446286.png)

ï¼ˆç”±äºä¸Šè¿°ä¸¤ä¸ªå€¼å‡æ˜¯å¸¸é‡ï¼Œå› æ­¤âœ¨çœ‹ä½œæ˜¯ç®€å•çš„åŠ å’Œè¿ç®—ï¼‰



ğŸ¤”å‡½æ•°åˆ†æï¼š
$$
l_t(m_i)=\log\frac{p(m_i|z_{1:t})}{p(\overline{m_i}|z_{1:t})}=\log\frac{p(m_i|z_{1:t})}{1-p(m_i|z_{1:t})}
$$
<img src="./Motion Planning.assets/image-20250418211554907.png" alt="image-20250418211554907" style="zoom: 80%;" />



### 3.Octo map

[OctoMap code](https://github.com/OctoMap/octomap)



### 4.Voxel Hashing 

[VoxelHashing](https://github.com/niessner/VoxelHashing)

<img src="./Motion Planning.assets/image-20250418025053216.png" alt="image-20250418025053216" style="zoom: 67%;" />

### 5.PointCloud Map



### 6.TSDF map(Truncated Signed Distance Function) 

* Code:

(1) [OpenChisel.](https://github.com/personalrobotics/OpenChisel)

(2) [tsdf-fusion-python](https://github.com/andyzeng/tsdf-fusion-python)



* æ¦‚è¿°ï¼šä¸€ä¸ªä¸‰ç»´çš„TSDFæ¨¡å‹ç”± LÃ—WÃ—H ä¸ªä¸‰ç»´å°æ–¹å—ç»„æˆï¼Œè¿™äº›ä¸‰ç»´å°æ–¹å—è¢«ç§°ä¸ºä½“ç´ (Voxel)ã€‚æ¯ä¸ªä½“ç´ å†…åŒ…å«ä¸¤ä¸ªå˜é‡ï¼Œä¸€æ˜¯ç”¨äºç”Ÿæˆé‡å»ºè¡¨é¢çš„**tsdfå€¼**ï¼ŒäºŒæ˜¯ç”¨äºé‡å»ºè¡¨é¢è´´çº¹ç†çš„**RGBå€¼**ã€‚

â€‹		è½¬æ¢ç‰©ç†åæ ‡ç³»åˆ°ä½“ç´ åæ ‡ç³»ï¼š$int ( ( x âˆ’ x0 ) / voxel.x , ( y âˆ’ y0 ) / voxel.y , ( z âˆ’ z0 ) / voxel.z )$



* è®¡ç®—æ­¥éª¤ï¼š
  

ï¼ˆ1ï¼‰**åˆ’åˆ†ä½“ç´ ** 
a. å»ºç«‹å®Œå…¨åŒ…å›´å¾…é‡å»ºç‰©ä½“çš„é•¿æ–¹ä½“åŒ…å›´ç›’  
b. åˆ’åˆ†ç½‘ç»œä½“ç´ ï¼Œå¯¹åŒ…å›´ç›’åˆ’åˆ† n ç­‰åˆ†  

![image-20250422192802474](./Motion%20Planning.assets/image-20250422192802474.png)

ï¼ˆ2ï¼‰**TSDF å€¼è®¡ç®—**
a.TSDF å€¼çš„å‰èº«æ˜¯ SDF å€¼ï¼š  
å¦‚ä¸‹å›¾ï¼Œç™½ç°è‰²çš„å°æ–¹æ ¼è¡¨ç¤º TSDF åœ°å›¾ä¸­çš„å„ä¸ªä½“ç´ ã€‚è“è‰²çš„ä¸‰è§’å½¢è¡¨ç¤ºç›¸æœºçš„è§†åœºèŒƒå›´ã€‚å›¾ä¸­é—´æœ‰ä¸€æ¡ç»¿è‰²çš„æˆªçº¿ï¼Œè¡¨ç¤ºä¸€ä¸ªç‰©ä½“çš„æˆªé¢ã€‚

   <img src="./Motion%20Planning.assets/v2-cd492bf5890102d89b5f026d3dfae3c8_1440w.jpg" alt="img" style="zoom: 80%;" />  

b.è®¡ç®—$voxel$åœ¨**ç‰©ç†åæ ‡**ä¸‹çš„ä½ç½®ï¼š  
è®°ä½“ç´ $x$åœ¨TSDFåœ°å›¾ä¸Šçš„åæ ‡ $(v_x, v_y, v_z)$, $x$åœ¨ç‰©ç†ä¸–ç•Œåæ ‡ç³»ä¸‹çš„ä½ç½®æ˜¯ï¼š  
$$
P_{x,wrd} = \big(x_0 + v_x \cdot \mathrm{voxel.x},~ y_0 + v_y \cdot \mathrm{voxel.y},~ z_0 + v_z \cdot \mathrm{voxel.z}\big)
$$

c.è®¡ç®—ä½“ç´ $x$åœ¨**ç›¸æœºåæ ‡**ç³»ä¸‹çš„ä½ç½®ï¼š  

è®¾ç›¸æœºç›¸å¯¹äºç‰©ç†åæ ‡ç³»ä¸‹çš„ä½å§¿æ˜¯ \(R\) å’Œ \(T\)ï¼Œä½“ç´  \(x\) åœ¨ç›¸æœºåæ ‡ç³»ä¸‹çš„ä½ç½®æ˜¯ï¼š  
$$
P_{x,cam} = \mathbf{R}P_{x,wrd} + T
$$

d.è®¡ç®—ä½“ç´  $x$ç›¸å¯¹äº**ç›¸æœºçš„æ·±åº¦** $cam_z(x)$ï¼š  

æ ¹æ®ç›¸æœºæˆåƒæ¨¡å‹  
$$
\mathrm{cam}_z(x) \cdot I_x = \mathbf{K}P_{x,cam}
$$
   ï¼ˆ$K$ è¡¨ç¤ºç›¸æœºçš„å†…å‚æ•°çŸ©é˜µï¼Œ$I_x$ è¡¨ç¤ºä½“ç´ $x$æŠ•å½±åœ¨ç›¸æœºæˆåƒå¹³é¢ä¸‹çš„åƒç´ åæ ‡ï¼‰  

   æ²¿ç€ç›¸æœºçš„å…‰å¿ƒå’Œä½“ç´  \(x\) ä½œä¸€æ¡ç›´çº¿ï¼ˆå›¾ä¸­æ·±è“è‰²ç²—çº¿ï¼‰ï¼Œè¿™æ¡çº¿ä¼šä¸**ç‰©ä½“çš„æˆªé¢**æœ‰ä¸€ä¸ªäº¤ç‚¹ï¼Œè¿™ä¸ªäº¤ç‚¹è®°ä¸º \(P\) ç‚¹ã€‚\(P\) ç‚¹çš„æ·±åº¦è®°ä¸º \(d_P\)ã€‚è®°å½“å‰çš„**æ·±åº¦å›¾**ä¸º \(D\)ï¼Œåœ¨å®é™…è®¡ç®—ä¸­å– \(d_P = D(I_x)\)ã€‚é‚£ä¹ˆä½“ç´  \(x\) çš„ SDF å€¼å°±å¯ä»¥è®¡ç®—å‡ºæ¥ï¼š  
$$
\mathrm{sdf}(x) = d_P - d_x = D(I_x) - \mathrm{cam}_z(x)
$$

e. è®¡ç®— TSDF å€¼ï¼š  

   $sdf(x) > 0$è¡¨ç¤ºä½“ç´  \(x\) ä½äºç›¸æœºå’Œç‰©ä½“è¡¨é¢ä¹‹é—´ï¼›$sdf(x) < 0$è¡¨  ç¤ºä½“ç´  $x$ å¤„äºç‰©ä½“è¡¨é¢ä¹‹åã€‚  

   TSDF è®¡ç®—å…¬å¼å¦‚ä¸‹ï¼š  
$$
\mathrm{tsdf}(x) = \max[-1, \min(1, \mathrm{sdf}(x) / t)]
$$

ğŸ¤”**ç‰©ç†æ„ä¹‰å¦‚ä¸‹ï¼š**

$t$å¯ä»¥çœ‹ä½œæ˜¯**ä½“ç´  $x$** å’Œ**æˆªé¢å¯¹åº”ç‚¹ $P$ æ·±åº¦**å·®å€¼çš„é˜ˆå€¼ã€‚å½“ä½“ç´ ç¦»è¡¨é¢éå¸¸è¿‘çš„æ—¶å€™ï¼ŒTSDF å€¼æ¥è¿‘äºé›¶ï¼›å½“ä½“ç´ ç¦»è¡¨é¢éå¸¸è¿œçš„æ—¶å€™ï¼ŒTSDF å€¼è¶‹äº 1 æˆ–è€… -1ã€‚åˆå§‹åŒ–æ—¶è®¾æ‰€æœ‰ä½“ç´ çš„ TSDF å€¼ä¸º 1ï¼Œç›¸å½“äºè¿™ä¸ª TSDF åœ°å›¾ä¸­æ²¡æœ‰ä»»ä½•è¡¨é¢ã€‚

ï¼ˆ3ï¼‰**å½“å‰å¸§ä¸å…¨å±€èåˆç»“æœè¿›è¡Œèåˆ**
$$
\begin{aligned}&TSDF(p)=\frac{W(p)TSDF(p)+w(p)tsdf(p)}{W(p)+w(p)}\\&W(p)=W(p)+w(p)\end{aligned}
$$

â€‹	



### 7.ESDF map 

* Code: 

(1) [FIESTA: Fast Incremental Euclidean Distance Fields for Online Motion Planning of Aerial Robots](https://github.com/HKUST-Aerial-Robotics/FIESTA)

(2) [voxblox: A library for flexible voxel-based mapping](https://github.com/ethz-asl/voxblox)

(3) [nvblox: A GPU-accelerated TSDF and ESDF library for robots equipped with RGB-D cameras.](https://github.com/nvidia-isaac/nvblox)

* Paper:                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      

(1) [Distance Transforms of Sampled Functions](https://cs.brown.edu/people/pfelzens/papers/dt-final.pdf)

(2) [Improved updating of Euclidean distance maps and Voronoi diagrams](https://ieeexplore.ieee.org/abstract/document/5650794)

(3) [nvblox](https://arxiv.org/pdf/2311.00626)

* æ¦‚å¿µï¼š

![image-20250427221928630](./Motion Planning.assets/image-20250427221928630-1745763577217-1.png)

å·¦ï¼šOccupancy æ¯ä¸ªæ ¼å­è¡¨ç¤ºå æ®æˆ–ç©ºä½™

å³ï¼šESDF æ¯ä¸ªæ ¼å­è¡¨ç¤ºåˆ°è¡¨é¢çš„æ¬§æ°è·ç¦»

* æ¬§å‡ é‡Œå¾—è·ç¦»å˜æ¢(EDT)ç®—æ³•ï¼š

ç›®æ ‡ï¼š**å¯¹äºæ¯ä¸€ä¸ªç‚¹pï¼Œå¯»æ‰¾ä¸€ä¸ªéšœç¢ç‰©ç‚¹qç¦»pç‚¹æœ€è¿‘ï¼Œå…¶ä¸­f(q)çœ‹ä½œæ˜¯qç‚¹çš„æ¶ˆè€—å‡½æ•°(æ˜¯ä¸€ä¸ªæå°é‡)ã€‚**

(1) ä¸€ç»´æƒ…å†µï¼šåœ°å›¾ä¸­ç‚¹åˆ°æ …æ ¼ä¸­éšœç¢ç‰©çš„å¹³æ–¹æ¬§æ°è·ç¦»å¯ä»¥ç”¨äºŒæ¬¡å‡½æ•°è¡¨ç¤ºã€‚


$$
\mathcal{D}\left(p\right)=\min_{q\in\mathcal{G}}\{(p-q)^{2}+f(q)\}
$$
$\mathcal{D}\left(p\right)$ â€” ä¸€ç»´ç©ºé—´ä¸­çš„ç‚¹påˆ°éšœç¢ç‰©çš„æ¬§æ°è·ç¦»

${q\in\mathcal{G}}$ â€” åœ¨æ …æ ¼åœ°å›¾Gä¸­è·ç¦»ç‚¹pæœ€è¿‘çš„éšœç¢ç‰©q

f(q) â€” qçš„é‡‡æ ·å‡½æ•°

![image-20250429151950114](./Motion Planning.assets/image-20250429151950114-1745911193883-2.png)

 $\mathcal{D}\left(p\right)$ â€” è·ç¦»å‡½æ•°å¯ä»¥çœ‹ä½œæ˜¯ä»¥(q, f(q))ä¸ºæœ€å°å€¼çš„æŠ›ç‰©çº¿ï¼Œå¯¹äºnä¸ªqç‚¹ï¼Œå³æœ‰nä¸ªä»¥(q, f(q))ä¸ºæœ€å°å€¼çš„æŠ›ç‰©çº¿ã€‚

ğŸ¤”æ ¸å¿ƒæ€æƒ³ï¼šå› æ­¤ï¼Œå¯¹äºå±äº[0, n-1]çš„pæ¥è¯´ï¼Œå…¶**EDTå°±æ˜¯è¿™äº›æŠ›ç‰©çº¿çš„ä¸‹åŒ…ç»œ(lower envelop)ã€‚**



<img src="./Motion Planning.assets/image-20250429160548524-1745913949880-4.png" alt="image-20250429160548524" style="zoom:80%;" />

ç”¨kè¡¨ç¤ºç”¨æ¥æ„æˆä¸‹åŒ…ç»œçš„æŠ›ç‰©çº¿ä¸ªæ•°ï¼Œv[k]è¡¨ç¤ºç¬¬kä¸ªæŠ›ç‰©çº¿çš„é¡¶ç‚¹ï¼Œz[k]å’Œz[k+1]è¡¨ç¤ºç¬¬kä¸ªæŠ›ç‰©çº¿åœ¨æ•´ä¸ªä¸‹åŒ…ç»œä¸­çš„æœ‰æ•ˆèŒƒå›´ï¼Œå…¶ä¸­z[k]è¡¨ç¤ºç¬¬kä¸ªæŠ›ç‰©çº¿ä¸ç¬¬k-1ä¸ªæŠ›ç‰©çº¿çš„äº¤ç‚¹ã€‚

ğŸ™Œè®¨è®ºï¼šå‡è®¾ä¸€**é¡¶ç‚¹ä¸ºqçš„æ–°æŠ›ç‰©çº¿**ä¸**åŸæœ‰ä¸‹åŒ…ç»œçº¿æœ€å³ä¾§æŠ›ç‰©çº¿v [ k ]**çš„äº¤ç‚¹ä¸ºsï¼Œè¯¥äº¤ç‚¹çš„ä½ç½®åªå­˜åœ¨ä¸¤ç§å¯èƒ½ï¼šäº¤ç‚¹såœ¨ z [ k ]å·¦è¾¹æˆ–åœ¨z[ k ]å³é¢ã€‚

ä»»æ„ä¸¤ä¸ªæŠ›ç‰©çº¿æœ‰ä¸”ä»…æœ‰ä¸€ä¸ªäº¤ç‚¹ï¼Œå…¶åœ¨ä¸€ç»´åæ ‡è½´çš„æŠ•å½±ä½ç½®sè®¡ç®—å¦‚ä¸‹ï¼š
$$
s=\frac{(f(r)+r^2)-(f(q)+q^2)}{2r-2q}
$$
ç°å¯¹z[k]å’Œsçš„ä½ç½®è¿›è¡Œè®¨è®ºï¼š

a. è‹¥äº¤ç‚¹ s åœ¨ z [ k ] å³è¾¹ï¼Œå³ s > z [ k ] ï¼Œåˆ™å°†æŠ›ç‰©çº¿ q æ·»åŠ ä¸ºä¸‹åŒ…ç»œæœ€å³è¾¹çš„æŠ›ç‰©çº¿ï¼Œæœ‰k = k + 1 ï¼Œv [ k ] = qï¼Œz [ k ] = sï¼Œz [ k + 1 ] = + âˆ 

b. è‹¥äº¤ç‚¹ s åœ¨ z [ k ]  å·¦è¾¹ï¼Œå³ s < z [ k ] ï¼Œåˆ™**å°†ä¸‹åŒ…ç»œåŸæœ‰çš„æŠ›ç‰©çº¿ v [ k ] åˆ é™¤ï¼Œå¹¶æœ‰k = k âˆ’ 1** (æ­¤å¤„ç”¨æ¥ä¿è¯è¯¥äº¤ç‚¹æ°¸è¿œæ˜¯æœ€å°å€¼)ï¼Œç„¶åé‡æ–°è®¡ç®—æŠ›ç‰©çº¿qä¸ä¸‹åŒ…ç»œæ­¤æ—¶æœ€å³ä¾§çš„æŠ›ç‰©çº¿ v [ k ]çš„äº¤ç‚¹ s ï¼Œå¹¶é‡å¤ä¸Šè¿°è¿‡ç¨‹ï¼Œç›´åˆ°äº¤ç‚¹ s åœ¨ z [ k ]å³è¾¹ã€‚

âœ¨ç®—æ³•ï¼š

![image-20250429180012616](./Motion Planning.assets/image-20250429180012616-1745920815169-6.png)

```c++
//one dimension
template <typename F_get_val, typename F_set_val>
void SDFMap::fillESDF(F_get_val f_get_val, F_set_val f_set_val, int start, int end, int dim) {
  int v[mp_.map_voxel_num_(dim)];
  double z[mp_.map_voxel_num_(dim) + 1];

  int k = start;
  v[start] = start;
  z[start] = -std::numeric_limits<double>::max();
  z[start + 1] = std::numeric_limits<double>::max();

  for (int q = start + 1; q <= end; q++) {
    k++;
    double s;

    do {
      k--;
      s = ((f_get_val(q) + q * q) - (f_get_val(v[k]) + v[k] * v[k])) / (2 * q - 2 * v[k]);
    } while (s <= z[k]);

    k++;

    v[k] = q;
    z[k] = s;
    z[k + 1] = std::numeric_limits<double>::max();
  }

  k = start;

  for (int q = start; q <= end; q++) {
    while (z[k + 1] < q) k++;
    double val = (q - v[k]) * (q - v[k]) + f_get_val(v[k]);
    f_set_val(q, val);
  }
}

```



(2) äºŒç»´æƒ…å†µï¼š

å¯¹äº$\mathcal{G}=\{0,\ldots,n-1\}\times\{0,\ldots,m-1\}$äºŒç»´æ …æ ¼ï¼Œæ¬§æ°è·ç¦»å¹³æ–¹å˜æ¢ä¸ºï¼š
$$
D_f(x,y)=\min_{x^{\prime},y^{\prime}}\left((x-x^{\prime})^2+(y-y^{\prime})^2+f(x^{\prime},y^{\prime})\right)
$$
åŒ–ç®€ä¸ºï¼š

(å…¶ä¸­$\mathcal{D}_{f|_{x^{\prime}}}(y)$æ˜¯fè¢«é™å®šåœ¨åˆ—ä¸ºx'çš„ä¸€ç»´è·ç¦»å˜æ¢ï¼Œ(x', y')ä¸ºéšœç¢ç‰©çš„åæ ‡)
$$
\begin{aligned}D_{f}(x,y)&=\min_{x^{\prime}}\left\{(x-x^{\prime})^{2}+\min_{y^{\prime}}\{(y-y^{\prime})^{2}\}\right\}\\&=\min_{x^{\prime}}\{(x-x^{\prime})^{2}+\mathcal{D}_{f|x^{\prime}}(x^{\prime},y)\}\end{aligned}
$$
å…ˆè®¡ç®—æ¯ä¸€åˆ—çš„çºµå‘EDTï¼šxå›ºå®šï¼Œæ ¼å­ä¸­è¡¨ç¤ºè¯¥ç‚¹è·ç¦»è¯¥åˆ—éšœç¢ç‰©çš„è·ç¦»f(x')ï¼Œæ— ç©·è¡¨ç¤ºè¯¥åˆ—æ²¡æœ‰éšœç¢ç‰©ã€‚

![image-20250429183427676](./Motion Planning.assets/image-20250429183427676-1745922868906-10.png)

å†è®¡ç®—æ¯ä¸€è¡Œçš„EDTï¼šå›ºå®šyåæ ‡ï¼Œå³å¯å°†äºŒç»´é—®é¢˜å…ˆè½¬æ¢ä¸ºä¸€ç»´æƒ…å†µâ€”å¯»æ‰¾x'ä½¿å¾—D(x)minã€‚
$$
\mathcal{D}(x)=\operatorname*{min}_{x^{\prime}}\{(x-x^{\prime})^{2}+f(x^{\prime})\}
$$
eg:é€‰ä¸­x=1,y=1ï¼Œä¾æ¬¡ä»£å…¥åˆ°ä¸Šå¼ä¸­ï¼Œæ³¨æ„x'ä¸ºè¿™ä¸€è¡Œåˆ«çš„æ ¼å­

<img src="./Motion Planning.assets/image-20250429184105522-1745923266842-13.png" alt="image-20250429184105522" style="zoom: 67%;" />

æœ€ç»ˆç»“æœå¦‚ä¸‹ï¼š

![image-20250429184719854](./Motion Planning.assets/image-20250429184719854.png)

æŒ‘é€‰ç¬¬ä¸€è¡Œç”»å‡ºåæ ‡ï¼Œå¯è§ç½‘æ ¼ä¸­å€¼å³å¯¹åº”ä¸‹åŒ…ç»œçš„çºµåæ ‡

<img src="./Motion Planning.assets/220f23e618ef62b04c695019264520f0-1745923531706-17.png" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°" style="zoom: 80%;" />

```c++
//two dimensions
void SDFMap::updateESDF3d() {
  Eigen::Vector3i min_esdf = md_.local_bound_min_;
  Eigen::Vector3i max_esdf = md_.local_bound_max_;

  /* ========== compute positive DT ========== */

  for (int x = min_esdf[0]; x <= max_esdf[0]; x++) {
    for (int y = min_esdf[1]; y <= max_esdf[1]; y++) {
      fillESDF(
          [&](int z) {
            return md_.occupancy_buffer_inflate_[toAddress(x, y, z)] == 1 ?
                0 :
                std::numeric_limits<double>::max();
          },
          [&](int z, double val) { md_.tmp_buffer1_[toAddress(x, y, z)] = val; }, min_esdf[2],
          max_esdf[2], 2);
    }
  }

  for (int x = min_esdf[0]; x <= max_esdf[0]; x++) {
    for (int z = min_esdf[2]; z <= max_esdf[2]; z++) {
       //md_.tmp_buffer1_æ˜¯ä¸Šä¸€ç»´åº¦è®¡ç®—çš„ç»“æœï¼Œä½œä¸ºæœ¬ç»´åº¦è®¡ç®—çš„åŸºç¡€èµ‹ç»™ f(q) 
      fillESDF([&](int y) { return md_.tmp_buffer1_[toAddress(x, y, z)]; },
               [&](int y, double val) { md_.tmp_buffer2_[toAddress(x, y, z)] = val; }, min_esdf[1],
               max_esdf[1], 1);  
    }
  }

  for (int y = min_esdf[1]; y <= max_esdf[1]; y++) {
    for (int z = min_esdf[2]; z <= max_esdf[2]; z++) {
       //md_.tmp_buffer2_æ˜¯ä¸Šä¸€ç»´åº¦è®¡ç®—çš„ç»“æœï¼Œä½œä¸ºæœ¬ç»´åº¦è®¡ç®—çš„åŸºç¡€èµ‹ç»™ f(q) 
      fillESDF([&](int x) { return md_.tmp_buffer2_[toAddress(x, y, z)]; },
               [&](int x, double val) {
               md_.distance_buffer_[toAddress(x, y, z)] = mp_.resolution_ * std::sqrt(val);
                 //  min(mp_.resolution_ * std::sqrt(val),
                 //      md_.distance_buffer_[toAddress(x, y, z)]);
               },
               min_esdf[0], max_esdf[0], 0);
    }
  }

  /* ========== compute negative distance ========== */
  for (int x = min_esdf(0); x <= max_esdf(0); ++x)
    for (int y = min_esdf(1); y <= max_esdf(1); ++y)
      for (int z = min_esdf(2); z <= max_esdf(2); ++z) {

        int idx = toAddress(x, y, z);
        if (md_.occupancy_buffer_inflate_[idx] == 0) {
          md_.occupancy_buffer_neg[idx] = 1;

        } else if (md_.occupancy_buffer_inflate_[idx] == 1) {
          md_.occupancy_buffer_neg[idx] = 0;
        } else {
          ROS_ERROR("what?");
        }
      }

  ros::Time t1, t2;

  for (int x = min_esdf[0]; x <= max_esdf[0]; x++) {
    for (int y = min_esdf[1]; y <= max_esdf[1]; y++) {
      fillESDF(
          [&](int z) {
            return md_.occupancy_buffer_neg[x * mp_.map_voxel_num_(1) * mp_.map_voxel_num_(2) +
                                            y * mp_.map_voxel_num_(2) + z] == 1 ?
                0 :
                std::numeric_limits<double>::max();
          },
          [&](int z, double val) { md_.tmp_buffer1_[toAddress(x, y, z)] = val; }, min_esdf[2],
          max_esdf[2], 2);
    }
  }

  for (int x = min_esdf[0]; x <= max_esdf[0]; x++) {
    for (int z = min_esdf[2]; z <= max_esdf[2]; z++) {
      fillESDF([&](int y) { return md_.tmp_buffer1_[toAddress(x, y, z)]; },
               [&](int y, double val) { md_.tmp_buffer2_[toAddress(x, y, z)] = val; }, min_esdf[1],
               max_esdf[1], 1);
    }
  }

  for (int y = min_esdf[1]; y <= max_esdf[1]; y++) {
    for (int z = min_esdf[2]; z <= max_esdf[2]; z++) {
      fillESDF([&](int x) { return md_.tmp_buffer2_[toAddress(x, y, z)]; },
               [&](int x, double val) {
                 md_.distance_buffer_neg_[toAddress(x, y, z)] = mp_.resolution_ * std::sqrt(val);
               },
               min_esdf[0], max_esdf[0], 0);
    }
  }

  /* ========== combine pos and neg DT ========== */
  for (int x = min_esdf(0); x <= max_esdf(0); ++x)
    for (int y = min_esdf(1); y <= max_esdf(1); ++y)
      for (int z = min_esdf(2); z <= max_esdf(2); ++z) {

        int idx = toAddress(x, y, z);
        md_.distance_buffer_all_[idx] = md_.distance_buffer_[idx];

        if (md_.distance_buffer_neg_[idx] > 0.0)
          md_.distance_buffer_all_[idx] += (-md_.distance_buffer_neg_[idx] + mp_.resolution_);
      }
}
```







## Chapter 2Â Path Finding

### 1.1 Search-based Method

1. Graph Search Basicï¼š

(1)çŠ¶æ€ç©ºé—´å›¾ï¼š

![image-20250430165656426](./Motion Planning.assets/image-20250430165656426-1746003431115-2.png)

(2)å›¾æœç´¢ç®—æ³•æ¡†æ¶ï¼š

a. ç»´æŠ¤ä¸€ä¸ªå®¹å™¨å»å­˜å‚¨æ‰€æœ‰è¦è®¿é—®çš„èŠ‚ç‚¹

b. ç”¨åˆå§‹èŠ‚ç‚¹$X_s$å»åˆå§‹åŒ–å®¹å™¨

c. å¾ªç¯ç»“æ„ï¼š 

æ ¹æ®**äº‹å…ˆç»™å®šçš„è§„åˆ™**popä¸€ä¸ªèŠ‚ç‚¹X

è·å–èŠ‚ç‚¹Xæ‰€æœ‰çš„é‚»å±…èŠ‚ç‚¹

å°†æ‰€æœ‰é‚»å±…èŠ‚ç‚¹pushåˆ°å®¹å™¨

d. å½“å®¹å™¨å†…æ— ä»»ä½•èŠ‚ç‚¹æˆ–æ‰¾åˆ°ç›®æ ‡èŠ‚ç‚¹æ—¶ç»“æŸå¾ªç¯



2. BFSï¼†DFS

BFSï¼š
DFSï¼š

![image-20250430170504632](./Motion Planning.assets/image-20250430170504632-1746003905979-4.png)



### 1.2 Sampling-based Method







### 1.3



## Chapter 2 







# Autonomus Cars
