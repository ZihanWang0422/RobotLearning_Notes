# Mobile Robots

[可视化Python](https://github.com/zhm-real/PathPlanning)

[MRPT](https://docs.mrpt.org/reference/latest/index.html)

## Chapter 1 Mapping

### 1.structure

<img src="./Motion Planning.assets/image-20250417095645143.png" alt="image-20250417095645143" style="zoom: 50%;" />

### 2.Occupancy grid map 

[grid map code](https://github.com/ANYbotics/grid_map)

* 原理：将平面地图通过grid进行分割，每个栅格用0,1表示（0 - free，1 - occupied）

  ![image-20250418120646301](./Motion Planning.assets/image-20250418120646301.png)

* Notation Defination

![image-20250418121448522](./Motion Planning.assets/image-20250418121448522.png)

<img src="./Motion Planning.assets/image-20250418122148617.png" alt="image-20250418122148617" style="zoom: 80%;" />

* Recursive Update

🙌推导：由贝叶斯公式：
$$
\begin{aligned}p(m_{i}|z_{1:t}) & =\frac{p(z_{t}|z_{1:t-1},m_{i})p(m_{i}|z_{1:t-1})}{p(z_{t}|z_{1:t-1})}\\  & \left(马尔科夫过程\right)=\frac{p(z_{t}|m_{i})p(m_{i}|z_{1:t-1})}{p(z_{t}|z_{1:t-1})}\\  & (贝叶斯展开)=\frac{p(m_{i}|z_{t})p(z_{t})}{p(m_{i})}\frac{p(m_{i}|z_{1:t-1})}{p(z_{t}|z_{1:t-1})}\end{aligned}
$$

$$
p(\overline{m_i}|z_{1:t})=\frac{p(\overline{m_i}|z_t)p(z_t)}{p(\overline{m_i})}\frac{p(\overline{m_i}|z_{1:t-1})}{p(z_t|z_{1:t-1})}
$$

 对上述两式相除，并取log：
$$
\log\frac{p(m_i|z_{1:t})}{p(\overline{m_i}|z_{1:t})}=\log\frac{p(m_i|z_t)}{p(\overline{m_i}|z_t)}\frac{p(\overline{m_i})}{p(m_i)}\frac{p(m_i|z_{1:t-1})}{p(\overline{m_i}|z_{1:t-1})}
$$
递归更新表达式：（化简log -> l）
$$
l_{t}(m_{i})=\log\frac{p(m_{i}|z_{t})}{p(\overline{m_{i}}|z_{t})}-l_0(m_i)+l_{t-1}(m_{i})
$$
其中，

P(z|m)是传感器模型 - 表示基于当前栅格状态得到当前观测值为0/1的概率

P(m|z)是逆传感器模型，为了约去它，做如下变换，并带入到递归更新表达式中：
$$
\begin{cases}p(m_i|z_t)=\frac{p(z_t|m_i)p(m_i)}{p(z_t)}\\p(\overline{m_i}|z_t)=\frac{p(z_t|\overline{m_i})p(\overline{m_i})}{p(z_t)}&\end{cases}
$$

$$
\log\frac{p(m_i|z_t)}{p(\overline{m_i|z_t})}=\log\frac{p(z_t|m_i)}{p(z_t|\overline{m_i})}+l_0(m_i)
$$

$$
✨l_t(m_i)=\log\frac{p(z_t|m_i)}{p(z_t|\overline{m_i})}+l_{t-1}(m_i)
$$

![image-20250418210446286](./Motion Planning.assets/image-20250418210446286.png)

（由于上述两个值均是常量，因此✨看作是简单的加和运算）



🤔函数分析：
$$
l_t(m_i)=\log\frac{p(m_i|z_{1:t})}{p(\overline{m_i}|z_{1:t})}=\log\frac{p(m_i|z_{1:t})}{1-p(m_i|z_{1:t})}
$$
<img src="./Motion Planning.assets/image-20250418211554907.png" alt="image-20250418211554907" style="zoom: 80%;" />



### 3.Octo map

[OctoMap code](https://github.com/OctoMap/octomap)



### 4.Voxel Hashing 

[VoxelHashing](https://github.com/niessner/VoxelHashing)

<img src="./Motion Planning.assets/image-20250418025053216.png" alt="image-20250418025053216" style="zoom: 67%;" />

### 5.PointCloud Map



### 6.TSDF map(Truncated Signed Distance Function) 

* Code:

(1) [OpenChisel.](https://github.com/personalrobotics/OpenChisel)

(2) [tsdf-fusion-python](https://github.com/andyzeng/tsdf-fusion-python)



* 概述：一个三维的TSDF模型由 L×W×H 个三维小方块组成，这些三维小方块被称为体素(Voxel)。每个体素内包含两个变量，一是用于生成重建表面的**tsdf值**，二是用于重建表面贴纹理的**RGB值**。

​		转换物理坐标系到体素坐标系：$int ( ( x − x0 ) / voxel.x , ( y − y0 ) / voxel.y , ( z − z0 ) / voxel.z )$



* 计算步骤：
  

（1）**划分体素** 
a. 建立完全包围待重建物体的长方体包围盒  
b. 划分网络体素，对包围盒划分 n 等分  

![image-20250422192802474](./Motion%20Planning.assets/image-20250422192802474.png)

（2）**TSDF 值计算**
a.TSDF 值的前身是 SDF 值：  
如下图，白灰色的小方格表示 TSDF 地图中的各个体素。蓝色的三角形表示相机的视场范围。图中间有一条绿色的截线，表示一个物体的截面。

   <img src="./Motion%20Planning.assets/v2-cd492bf5890102d89b5f026d3dfae3c8_1440w.jpg" alt="img" style="zoom: 80%;" />  

b.计算$voxel$在**物理坐标**下的位置：  
记体素$x$在TSDF地图上的坐标 $(v_x, v_y, v_z)$, $x$在物理世界坐标系下的位置是：  
$$
P_{x,wrd} = \big(x_0 + v_x \cdot \mathrm{voxel.x},~ y_0 + v_y \cdot \mathrm{voxel.y},~ z_0 + v_z \cdot \mathrm{voxel.z}\big)
$$

c.计算体素$x$在**相机坐标**系下的位置：  

设相机相对于物理坐标系下的位姿是 \(R\) 和 \(T\)，体素 \(x\) 在相机坐标系下的位置是：  
$$
P_{x,cam} = \mathbf{R}P_{x,wrd} + T
$$

d.计算体素 $x$相对于**相机的深度** $cam_z(x)$：  

根据相机成像模型  
$$
\mathrm{cam}_z(x) \cdot I_x = \mathbf{K}P_{x,cam}
$$
   （$K$ 表示相机的内参数矩阵，$I_x$ 表示体素$x$投影在相机成像平面下的像素坐标）  

   沿着相机的光心和体素 \(x\) 作一条直线（图中深蓝色粗线），这条线会与**物体的截面**有一个交点，这个交点记为 \(P\) 点。\(P\) 点的深度记为 \(d_P\)。记当前的**深度图**为 \(D\)，在实际计算中取 \(d_P = D(I_x)\)。那么体素 \(x\) 的 SDF 值就可以计算出来：  
$$
\mathrm{sdf}(x) = d_P - d_x = D(I_x) - \mathrm{cam}_z(x)
$$

e. 计算 TSDF 值：  

   $sdf(x) > 0$表示体素 \(x\) 位于相机和物体表面之间；$sdf(x) < 0$表  示体素 $x$ 处于物体表面之后。  

   TSDF 计算公式如下：  
$$
\mathrm{tsdf}(x) = \max[-1, \min(1, \mathrm{sdf}(x) / t)]
$$

🤔**物理意义如下：**

$t$可以看作是**体素 $x$** 和**截面对应点 $P$ 深度**差值的阈值。当体素离表面非常近的时候，TSDF 值接近于零；当体素离表面非常远的时候，TSDF 值趋于 1 或者 -1。初始化时设所有体素的 TSDF 值为 1，相当于这个 TSDF 地图中没有任何表面。

（3）**当前帧与全局融合结果进行融合**
$$
\begin{aligned}&TSDF(p)=\frac{W(p)TSDF(p)+w(p)tsdf(p)}{W(p)+w(p)}\\&W(p)=W(p)+w(p)\end{aligned}
$$

​	



### 7.ESDF map 

* Code: 

(1) [FIESTA: Fast Incremental Euclidean Distance Fields for Online Motion Planning of Aerial Robots](https://github.com/HKUST-Aerial-Robotics/FIESTA)

(2) [voxblox: A library for flexible voxel-based mapping](https://github.com/ethz-asl/voxblox)

(3) [nvblox: A GPU-accelerated TSDF and ESDF library for robots equipped with RGB-D cameras.](https://github.com/nvidia-isaac/nvblox)

* Paper:                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      

(1) [Distance Transforms of Sampled Functions](https://cs.brown.edu/people/pfelzens/papers/dt-final.pdf)

(2) [Improved updating of Euclidean distance maps and Voronoi diagrams](https://ieeexplore.ieee.org/abstract/document/5650794)

(3) [nvblox](https://arxiv.org/pdf/2311.00626)

* 概念：

![image-20250427221928630](./Motion Planning.assets/image-20250427221928630-1745763577217-1.png)

左：Occupancy 每个格子表示占据或空余

右：ESDF 每个格子表示到表面的欧氏距离

* 欧几里得距离变换(EDT)算法：

目标：**对于每一个点p，寻找一个障碍物点q离p点最近，其中f(q)看作是q点的消耗函数(是一个极小量)。**

(1) 一维情况：地图中点到栅格中障碍物的平方欧氏距离可以用二次函数表示。


$$
\mathcal{D}\left(p\right)=\min_{q\in\mathcal{G}}\{(p-q)^{2}+f(q)\}
$$
$\mathcal{D}\left(p\right)$ — 一维空间中的点p到障碍物的欧氏距离

${q\in\mathcal{G}}$ — 在栅格地图G中距离点p最近的障碍物q

f(q) — q的采样函数

![image-20250429151950114](./Motion Planning.assets/image-20250429151950114-1745911193883-2.png)

 $\mathcal{D}\left(p\right)$ — 距离函数可以看作是以(q, f(q))为最小值的抛物线，对于n个q点，即有n个以(q, f(q))为最小值的抛物线。

🤔核心思想：因此，对于属于[0, n-1]的p来说，其**EDT就是这些抛物线的下包络(lower envelop)。**



<img src="./Motion Planning.assets/image-20250429160548524-1745913949880-4.png" alt="image-20250429160548524" style="zoom:80%;" />

用k表示用来构成下包络的抛物线个数，v[k]表示第k个抛物线的顶点，z[k]和z[k+1]表示第k个抛物线在整个下包络中的有效范围，其中z[k]表示第k个抛物线与第k-1个抛物线的交点。

🙌讨论：假设一**顶点为q的新抛物线**与**原有下包络线最右侧抛物线v [ k ]**的交点为s，该交点的位置只存在两种可能：交点s在 z [ k ]左边或在z[ k ]右面。

任意两个抛物线有且仅有一个交点，其在一维坐标轴的投影位置s计算如下：
$$
s=\frac{(f(r)+r^2)-(f(q)+q^2)}{2r-2q}
$$
现对z[k]和s的位置进行讨论：

a. 若交点 s 在 z [ k ] 右边，即 s > z [ k ] ，则将抛物线 q 添加为下包络最右边的抛物线，有k = k + 1 ，v [ k ] = q，z [ k ] = s，z [ k + 1 ] = + ∞ 

b. 若交点 s 在 z [ k ]  左边，即 s < z [ k ] ，则**将下包络原有的抛物线 v [ k ] 删除，并有k = k − 1** (此处用来保证该交点永远是最小值)，然后重新计算抛物线q与下包络此时最右侧的抛物线 v [ k ]的交点 s ，并重复上述过程，直到交点 s 在 z [ k ]右边。

✨算法：

![image-20250429180012616](./Motion Planning.assets/image-20250429180012616-1745920815169-6.png)

```c++
//one dimension
template <typename F_get_val, typename F_set_val>
void SDFMap::fillESDF(F_get_val f_get_val, F_set_val f_set_val, int start, int end, int dim) {
  int v[mp_.map_voxel_num_(dim)];
  double z[mp_.map_voxel_num_(dim) + 1];

  int k = start;
  v[start] = start;
  z[start] = -std::numeric_limits<double>::max();
  z[start + 1] = std::numeric_limits<double>::max();

  for (int q = start + 1; q <= end; q++) {
    k++;
    double s;

    do {
      k--;
      s = ((f_get_val(q) + q * q) - (f_get_val(v[k]) + v[k] * v[k])) / (2 * q - 2 * v[k]);
    } while (s <= z[k]);

    k++;

    v[k] = q;
    z[k] = s;
    z[k + 1] = std::numeric_limits<double>::max();
  }

  k = start;

  for (int q = start; q <= end; q++) {
    while (z[k + 1] < q) k++;
    double val = (q - v[k]) * (q - v[k]) + f_get_val(v[k]);
    f_set_val(q, val);
  }
}

```



(2) 二维情况：

对于$\mathcal{G}=\{0,\ldots,n-1\}\times\{0,\ldots,m-1\}$二维栅格，欧氏距离平方变换为：
$$
D_f(x,y)=\min_{x^{\prime},y^{\prime}}\left((x-x^{\prime})^2+(y-y^{\prime})^2+f(x^{\prime},y^{\prime})\right)
$$
化简为：

(其中$\mathcal{D}_{f|_{x^{\prime}}}(y)$是f被限定在列为x'的一维距离变换，(x', y')为障碍物的坐标)
$$
\begin{aligned}D_{f}(x,y)&=\min_{x^{\prime}}\left\{(x-x^{\prime})^{2}+\min_{y^{\prime}}\{(y-y^{\prime})^{2}\}\right\}\\&=\min_{x^{\prime}}\{(x-x^{\prime})^{2}+\mathcal{D}_{f|x^{\prime}}(x^{\prime},y)\}\end{aligned}
$$
先计算每一列的纵向EDT：x固定，格子中表示该点距离该列障碍物的距离f(x')，无穷表示该列没有障碍物。

![image-20250429183427676](./Motion Planning.assets/image-20250429183427676-1745922868906-10.png)

再计算每一行的EDT：固定y坐标，即可将二维问题先转换为一维情况—寻找x'使得D(x)min。
$$
\mathcal{D}(x)=\operatorname*{min}_{x^{\prime}}\{(x-x^{\prime})^{2}+f(x^{\prime})\}
$$
eg:选中x=1,y=1，依次代入到上式中，注意x'为这一行别的格子

<img src="./Motion Planning.assets/image-20250429184105522-1745923266842-13.png" alt="image-20250429184105522" style="zoom: 67%;" />

最终结果如下：

![image-20250429184719854](./Motion Planning.assets/image-20250429184719854.png)

挑选第一行画出坐标，可见网格中值即对应下包络的纵坐标

<img src="./Motion Planning.assets/220f23e618ef62b04c695019264520f0-1745923531706-17.png" alt="在这里插入图片描述" style="zoom: 80%;" />

```c++
//two dimensions
void SDFMap::updateESDF3d() {
  Eigen::Vector3i min_esdf = md_.local_bound_min_;
  Eigen::Vector3i max_esdf = md_.local_bound_max_;

  /* ========== compute positive DT ========== */

  for (int x = min_esdf[0]; x <= max_esdf[0]; x++) {
    for (int y = min_esdf[1]; y <= max_esdf[1]; y++) {
      fillESDF(
          [&](int z) {
            return md_.occupancy_buffer_inflate_[toAddress(x, y, z)] == 1 ?
                0 :
                std::numeric_limits<double>::max();
          },
          [&](int z, double val) { md_.tmp_buffer1_[toAddress(x, y, z)] = val; }, min_esdf[2],
          max_esdf[2], 2);
    }
  }

  for (int x = min_esdf[0]; x <= max_esdf[0]; x++) {
    for (int z = min_esdf[2]; z <= max_esdf[2]; z++) {
       //md_.tmp_buffer1_是上一维度计算的结果，作为本维度计算的基础赋给 f(q) 
      fillESDF([&](int y) { return md_.tmp_buffer1_[toAddress(x, y, z)]; },
               [&](int y, double val) { md_.tmp_buffer2_[toAddress(x, y, z)] = val; }, min_esdf[1],
               max_esdf[1], 1);  
    }
  }

  for (int y = min_esdf[1]; y <= max_esdf[1]; y++) {
    for (int z = min_esdf[2]; z <= max_esdf[2]; z++) {
       //md_.tmp_buffer2_是上一维度计算的结果，作为本维度计算的基础赋给 f(q) 
      fillESDF([&](int x) { return md_.tmp_buffer2_[toAddress(x, y, z)]; },
               [&](int x, double val) {
               md_.distance_buffer_[toAddress(x, y, z)] = mp_.resolution_ * std::sqrt(val);
                 //  min(mp_.resolution_ * std::sqrt(val),
                 //      md_.distance_buffer_[toAddress(x, y, z)]);
               },
               min_esdf[0], max_esdf[0], 0);
    }
  }

  /* ========== compute negative distance ========== */
  for (int x = min_esdf(0); x <= max_esdf(0); ++x)
    for (int y = min_esdf(1); y <= max_esdf(1); ++y)
      for (int z = min_esdf(2); z <= max_esdf(2); ++z) {

        int idx = toAddress(x, y, z);
        if (md_.occupancy_buffer_inflate_[idx] == 0) {
          md_.occupancy_buffer_neg[idx] = 1;

        } else if (md_.occupancy_buffer_inflate_[idx] == 1) {
          md_.occupancy_buffer_neg[idx] = 0;
        } else {
          ROS_ERROR("what?");
        }
      }

  ros::Time t1, t2;

  for (int x = min_esdf[0]; x <= max_esdf[0]; x++) {
    for (int y = min_esdf[1]; y <= max_esdf[1]; y++) {
      fillESDF(
          [&](int z) {
            return md_.occupancy_buffer_neg[x * mp_.map_voxel_num_(1) * mp_.map_voxel_num_(2) +
                                            y * mp_.map_voxel_num_(2) + z] == 1 ?
                0 :
                std::numeric_limits<double>::max();
          },
          [&](int z, double val) { md_.tmp_buffer1_[toAddress(x, y, z)] = val; }, min_esdf[2],
          max_esdf[2], 2);
    }
  }

  for (int x = min_esdf[0]; x <= max_esdf[0]; x++) {
    for (int z = min_esdf[2]; z <= max_esdf[2]; z++) {
      fillESDF([&](int y) { return md_.tmp_buffer1_[toAddress(x, y, z)]; },
               [&](int y, double val) { md_.tmp_buffer2_[toAddress(x, y, z)] = val; }, min_esdf[1],
               max_esdf[1], 1);
    }
  }

  for (int y = min_esdf[1]; y <= max_esdf[1]; y++) {
    for (int z = min_esdf[2]; z <= max_esdf[2]; z++) {
      fillESDF([&](int x) { return md_.tmp_buffer2_[toAddress(x, y, z)]; },
               [&](int x, double val) {
                 md_.distance_buffer_neg_[toAddress(x, y, z)] = mp_.resolution_ * std::sqrt(val);
               },
               min_esdf[0], max_esdf[0], 0);
    }
  }

  /* ========== combine pos and neg DT ========== */
  for (int x = min_esdf(0); x <= max_esdf(0); ++x)
    for (int y = min_esdf(1); y <= max_esdf(1); ++y)
      for (int z = min_esdf(2); z <= max_esdf(2); ++z) {

        int idx = toAddress(x, y, z);
        md_.distance_buffer_all_[idx] = md_.distance_buffer_[idx];

        if (md_.distance_buffer_neg_[idx] > 0.0)
          md_.distance_buffer_all_[idx] += (-md_.distance_buffer_neg_[idx] + mp_.resolution_);
      }
}
```







## Chapter 2 Path Finding

### 1.1 Search-based Method

1. Graph Search Basic：

(1)状态空间图：

![image-20250430165656426](./Motion Planning.assets/image-20250430165656426-1746003431115-2.png)

(2)图搜索算法框架：

a. 维护一个容器去存储所有要访问的节点

b. 用初始节点$X_s$去初始化容器

c. 循环结构： 

根据**事先给定的规则**pop一个节点X

获取节点X所有的邻居节点

将所有邻居节点push到容器

d. 当容器内无任何节点或找到目标节点时结束循环



2. BFS＆DFS

BFS：
DFS：

![image-20250430170504632](./Motion Planning.assets/image-20250430170504632-1746003905979-4.png)



### 1.2 Sampling-based Method







### 1.3



## Chapter 2 







# Autonomus Cars
